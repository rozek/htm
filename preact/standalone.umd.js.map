{"version":3,"file":"standalone.umd.js","sources":["../src/constants.mjs","../src/build.mjs","../src/index.mjs","../src/integrations/preact/standalone.mjs"],"sourcesContent":["export const MINI = false;\n","import { MINI } from './constants.mjs';\n\nconst MODE_SLASH = 0;\nconst MODE_TEXT = 1;\nconst MODE_WHITESPACE = 2;\nconst MODE_TAGNAME = 3;\nconst MODE_COMMENT = 4;\nconst MODE_PROP_SET = 5;\nconst MODE_PROP_APPEND = 6;\n\nconst CHILD_APPEND = 0;\nconst CHILD_RECURSE = 2;\nconst TAG_SET = 3;\nconst PROPS_ASSIGN = 4;\nconst PROP_SET = MODE_PROP_SET;\nconst PROP_APPEND = MODE_PROP_APPEND;\n\n// Turn a result of a build(...) call into a tree that is more\n// convenient to analyze and transform (e.g. Babel plugins).\n// For example:\n// \ttreeify(\n//\t\tbuild`<div href=\"1${a}\" ...${b}><${x} /></div>`,\n//\t\t[X, Y, Z]\n//\t)\n// returns:\n// \t{\n// \t\ttag: 'div',\n//\t\tprops: [ { href: [\"1\", X] }, Y ],\n// \t\tchildren: [ { tag: Z, props: [], children: [] } ]\n// \t}\nexport const treeify = (built, fields) => {\n\tconst _treeify = built => {\n\t\tlet tag = '';\n\t\tlet currentProps = null;\n\t\tconst props = [];\n\t\tconst children = [];\n\n\t\tfor (let i = 1; i < built.length; i++) {\n\t\t\tconst type = built[i++];\n\t\t\tconst value = built[i] ? fields[built[i++]-1] : built[++i];\n\n\t\t\tif (type === TAG_SET) {\n\t\t\t\ttag = value;\n\t\t\t}\n\t\t\telse if (type === PROPS_ASSIGN) {\n\t\t\t\tprops.push(value);\n\t\t\t\tcurrentProps = null;\n\t\t\t}\n\t\t\telse if (type === PROP_SET) {\n\t\t\t\tif (!currentProps) {\n\t\t\t\t\tcurrentProps = Object.create(null);\n\t\t\t\t\tprops.push(currentProps);\n\t\t\t\t}\n\t\t\t\tcurrentProps[built[++i]] = [value];\n\t\t\t}\n\t\t\telse if (type === PROP_APPEND) {\n\t\t\t\tcurrentProps[built[++i]].push(value);\n\t\t\t}\n\t\t\telse if (type === CHILD_RECURSE) {\n\t\t\t\tchildren.push(_treeify(value));\n\t\t\t}\n\t\t\telse if (type === CHILD_APPEND) {\n\t\t\t\tchildren.push(value);\n\t\t\t}\n\t\t}\n\n\t\treturn { tag, props, children };\n\t};\n\tconst { children } = _treeify(built);\n\treturn children.length > 1 ? children : children[0];\n};\n\nexport const evaluate = (h, built, fields, args) => {\n\tlet tmp;\n\n\t// `build()` used the first element of the operation list as\n\t// temporary workspace. Now that `build()` is done we can use\n\t// that space to track whether the current element is \"dynamic\"\n\t// (i.e. it or any of its descendants depend on dynamic values).\n\tbuilt[0] = 0;\n\n\tfor (let i = 1; i < built.length; i++) {\n\t\tconst type = built[i++];\n\n\t\t// Set `built[0]`'s appropriate bits if this element depends on a dynamic value.\n\t\tconst value = built[i] ? ((built[0] |= type ? 1 : 2), fields[built[i++]]) : built[++i];\n\n\t\tif (type === TAG_SET) {\n\t\t\targs[0] = value;\n\t\t}\n\t\telse if (type === PROPS_ASSIGN) {\n\t\t\targs[1] = Object.assign(args[1] || {}, value);\n\t\t}\n\t\telse if (type === PROP_SET) {\n\t\t\t(args[1] = args[1] || {})[built[++i]] = value;\n\t\t}\n\t\telse if (type === PROP_APPEND) {\n\t\t\targs[1][built[++i]] += (value + '');\n\t\t}\n\t\telse if (type) { // type === CHILD_RECURSE\n\t\t\t// Set the operation list (including the staticness bits) as\n\t\t\t// `this` for the `h` call.\n\t\t\ttmp = h.apply(value, evaluate(h, value, fields, ['', null]));\n\t\t\targs.push(tmp);\n\n\t\t\tif (value[0]) {\n\t\t\t\t// Set the 2nd lowest bit it the child element is dynamic.\n\t\t\t\tbuilt[0] |= 2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Rewrite the operation list in-place if the child element is static.\n\t\t\t\t// The currently evaluated piece `CHILD_RECURSE, 0, [...]` becomes\n\t\t\t\t// `CHILD_APPEND, 0, tmp`.\n\t\t\t\t// Essentially the operation list gets optimized for potential future\n\t\t\t\t// re-evaluations.\n\t\t\t\tbuilt[i-2] = CHILD_APPEND;\n\t\t\t\tbuilt[i] = tmp;\n\t\t\t}\n\t\t}\n\t\telse { // type === CHILD_APPEND\n\t\t\targs.push(value);\n\t\t}\n\t}\n\n\treturn args;\n};\n\nexport const build = function(statics) {\n\tconst fields = arguments;\n\tconst h = this;\n\n\tlet mode = MODE_TEXT;\n\tlet buffer = '';\n\tlet quote = '';\n\tlet current = [0];\n\tlet char, propName;\n\n\tconst commit = field => {\n\t\tif (mode === MODE_TEXT && (field || (buffer = buffer.replace(/^\\s*\\n\\s*|\\s*\\n\\s*$/g,'')))) {\n\t\t\tif (MINI) {\n\t\t\t\tcurrent.push(field ? fields[field] : buffer);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcurrent.push(CHILD_APPEND, field, buffer);\n\t\t\t}\n\t\t}\n\t\telse if (mode === MODE_TAGNAME && (field || buffer)) {\n\t\t\tif (MINI) {\n\t\t\t\tcurrent[1] = field ? fields[field] : buffer;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcurrent.push(TAG_SET, field, buffer);\n\t\t\t}\n\t\t\tmode = MODE_WHITESPACE;\n\t\t}\n\t\telse if (mode === MODE_WHITESPACE && buffer === '...' && field) {\n\t\t\tif (MINI) {\n\t\t\t\tcurrent[2] = Object.assign(current[2] || {}, fields[field]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcurrent.push(PROPS_ASSIGN, field, 0);\n\t\t\t}\n\t\t}\n\t\telse if (mode === MODE_WHITESPACE && buffer && !field) {\n\t\t\tif (MINI) {\n\t\t\t\t(current[2] = current[2] || {})[buffer] = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcurrent.push(PROP_SET, 0, true, buffer);\n\t\t\t}\n\t\t}\n\t\telse if (mode >= MODE_PROP_SET) {\n\t\t\tif (MINI) {\n\t\t\t\tif (mode === MODE_PROP_SET) {\n\t\t\t\t\t(current[2] = current[2] || {})[propName] = field ? buffer ? (buffer + fields[field]) : fields[field] : buffer;\n\t\t\t\t\tmode = MODE_PROP_APPEND;\n\t\t\t\t}\n\t\t\t\telse if (field || buffer) {\n\t\t\t\t\tcurrent[2][propName] += field ? buffer + fields[field] : buffer;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (buffer || (!field && mode === MODE_PROP_SET)) {\n\t\t\t\t\tcurrent.push(mode, 0, buffer, propName);\n\t\t\t\t\tmode = MODE_PROP_APPEND;\n\t\t\t\t}\n\t\t\t\tif (field) {\n\t\t\t\t\tcurrent.push(mode, field, 0, propName);\n\t\t\t\t\tmode = MODE_PROP_APPEND;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbuffer = '';\n\t};\n\n\tfor (let i=0; i<statics.length; i++) {\n\t\tif (i) {\n\t\t\tif (mode === MODE_TEXT) {\n\t\t\t\tcommit();\n\t\t\t}\n\t\t\tcommit(i);\n\t\t}\n\n\t\tfor (let j=0; j<statics[i].length;j++) {\n\t\t\tchar = statics[i][j];\n\n\t\t\tif (mode === MODE_TEXT) {\n\t\t\t\tif (char === '<') {\n\t\t\t\t\t// commit buffer\n\t\t\t\t\tcommit();\n\t\t\t\t\tif (MINI) {\n\t\t\t\t\t\tcurrent = [current, '', null];\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tcurrent = [current];\n\t\t\t\t\t}\n\t\t\t\t\tmode = MODE_TAGNAME;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbuffer += char;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (mode === MODE_COMMENT) {\n\t\t\t\t// Ignore everything until the last three characters are '-', '-' and '>'\n\t\t\t\tif (buffer === '--' && char === '>') {\n\t\t\t\t\tmode = MODE_TEXT;\n\t\t\t\t\tbuffer = '';\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbuffer = char + buffer[0];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (quote) {\n\t\t\t\tif (char === quote) {\n\t\t\t\t\tquote = '';\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbuffer += char;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (char === '\"' || char === \"'\") {\n\t\t\t\tquote = char;\n\t\t\t}\n\t\t\telse if (char === '>') {\n\t\t\t\tcommit();\n\t\t\t\tmode = MODE_TEXT;\n\t\t\t}\n\t\t\telse if (!mode) {\n\t\t\t\t// Ignore everything until the tag ends\n\t\t\t}\n\t\t\telse if (char === '=') {\n\t\t\t\tmode = MODE_PROP_SET;\n\t\t\t\tpropName = buffer;\n\t\t\t\tbuffer = '';\n\t\t\t}\n\t\t\telse if (char === '/' && (mode < MODE_PROP_SET || statics[i][j+1] === '>')) {\n\t\t\t\tcommit();\n\t\t\t\tif (mode === MODE_TAGNAME) {\n\t\t\t\t\tcurrent = current[0];\n\t\t\t\t}\n\t\t\t\tmode = current;\n\t\t\t\tif (MINI) {\n\t\t\t\t\t(current = current[0]).push(h.apply(null, mode.slice(1)));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t(current = current[0]).push(CHILD_RECURSE, 0, mode);\n\t\t\t\t}\n\t\t\t\tmode = MODE_SLASH;\n\t\t\t}\n\t\t\telse if (char === ' ' || char === '\\t' || char === '\\n' || char === '\\r') {\n\t\t\t\t// <a disabled>\n\t\t\t\tcommit();\n\t\t\t\tmode = MODE_WHITESPACE;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbuffer += char;\n\t\t\t}\n\n\t\t\tif (mode === MODE_TAGNAME && buffer === '!--') {\n\t\t\t\tmode = MODE_COMMENT;\n\t\t\t\tcurrent = current[0];\n\t\t\t}\n\t\t}\n\t}\n\tcommit();\n\n\tif (MINI) {\n\t\treturn current.length > 2 ? current.slice(1) : current[1];\n\t}\n\treturn current;\n};\n","/**\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { MINI } from './constants.mjs';\nimport { build, evaluate } from './build.mjs';\n\nconst CACHES = new Map();\n\nconst regular = function(statics) {\n\tlet tmp = CACHES.get(this);\n\tif (!tmp) {\n\t\ttmp = new Map();\n\t\tCACHES.set(this, tmp);\n\t}\n\ttmp = evaluate(this, tmp.get(statics) || (tmp.set(statics, tmp = build(statics)), tmp), arguments, []);\n\treturn tmp.length > 1 ? tmp : tmp[0];\n};\n\nexport default MINI ? build : regular;\n","/**\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { h, createElement, cloneElement, Component, createContext, createRef, render, hydrate, toChildArray } from 'preact';\nimport { useState, useReducer, useEffect, useLayoutEffect, useRef, useImperativeHandle, useMemo, useCallback, useContext, useDebugValue, useErrorBoundary, useId } from 'preact/hooks';\n// import { /*signal, computed, effect, batch,*/ untracked, useSignal, useComputed, useSignalEffect } from '@preact/signals';\nimport { createPortal } from 'preact/compat'\n\nimport htm from '../../index.mjs';\n\nconst html = htm.bind(h);\n\nexport {\n  html,\n  h, createElement, cloneElement, Component, createContext, createRef, render, hydrate, toChildArray,\n  useState, useReducer, useEffect, useLayoutEffect, useRef, useImperativeHandle, useMemo, useCallback, useContext, useDebugValue, useErrorBoundary, useId,\n  /*signal, computed, effect, batch, untracked, useSignal, useComputed, useSignalEffect,*/\n  createPortal\n};\n// export * from '@preact/signals-core'\n"],"names":["const","evaluate","h","built","fields","args","let","tmp","i","length","type","value","Object","assign","apply","push","CACHES","Map","html","statics","get","this","set","char","propName","mode","buffer","quote","current","commit","field","replace","j","build","arguments","bind"],"mappings":"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"}